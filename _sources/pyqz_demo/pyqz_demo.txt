
Running pyqz
============

This page is also available as an IPython notebook (pyqz\_demo.ipynb)
located in pyqz/examples.

Warning 1: the code syntax in v0.7.0 has changed significantly, and so
did the function calls. pyqz v0.7.x is therefore NOT backward compatible
with older pyqz versions.

Warning 2: the examples below will show you how to run the main
functions inside pyqz. But these do not exempt you from getting
acquinted with the Understanding pyqz section of the documentation !

Installing and importing pyqz
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Installing pyqz is easy. Download it from Github, unpack it anywhere you
like, and make sure that this location is in your Python path. You
should then be able to import the package and check its version from
within any Python shell:
::
    >>> import pyqz
    >>> pyqz.__version__
    '0.7.2'


Basic use 1: accessing MAPPINGS line ratio diagnostic grids
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

pyqz gives you easy access to the latest MAPPINGS strong line ratio
diagnostic diagrams (and associated info on the MAPPINGS version used to
generate the grid, etc...). This can for example be useful to create
your own line ratio diagnostic plots. You can access the nodes of any
line ratio diagram using pyqz.get\_grid():
::
    >>> a_grid = pyqz.get_grid('[NII]/[SII]+;[OIII]/[SII]+', sampling=1)
    >>> # Uncomment the line below for a look at the structure of a_grid
    >>> # print a_grid

The main parameters of the MAPPINGS simulations can be specified via the
following keywords: - Pk let's you define the pressure of the simulated
HII regions, - struct allows you to choose between plane-parallel ('pp')
and spherical ('sph') HII regions, and - kappa lets you define the value
of :math:`\kappa` (from the so-called :math:`\kappa`-distribution).

All these values must match an existing set of MAPPINGS simulations
inside the pyqz/reference\_data/ folder, or pyqz will issue an error. In
other words, pyqz will not be running new MAPPINGS simulations for you.

So, if one wanted to access the MAPPINGS simulations for plane-parallel
HII regions, with Maxwell-Boltzmann electron density distribution, Pk
=5.0, one should type:
::
    >>> a_grid = pyqz.get_grid('[NII]/[SII]+;[OIII]/[SII]+', struct = 'pp', Pk = 5, kappa = 'inf')
    >>> # Uncomment the line below for a look at the structure of a_grid
    >>> # print a_grid

If you want to simply check how a given line ratio diagnostic diagram
looks (and e.g. check whether the MAPPINGS grid is flat, or wrapped) for
line ratios of your choice, you can use pyqz.check\_grid():
::
    >>> bad_segments = pyqz.check_grid('[NII]/[OII]+;[OIII]/[SII]+', show_plot=True)

An important feature of pyqz is the auto-detection of wraps in the
diagnostic grids, marked with red segments in the diagram, and returned
as an array by the function pyqz.check\_grid().

By default, the default MAPPINGS grids shipped with pyqz are corse. For
various reasons better explained elsewhere (see the MAPPINGS
documentation), only a few abundance values have matching stellar tracks
AND stellar atmospheres. Hence, only a few abundance points can be
simulated in a consistent fashion.

Rather than 1) interpolating between stellar tracks and stellar
atmospheres in the abundance space and 2) running extra MAPPINGS models
(which would use inconsistent & interpolated input), pyqz can directly
resample each diagnostic grid (using the function
pyqz.refine\_MVphotogrid(), see the docs for more info). The resampling
is performed in the {logQ and Tot[O+12] vs line ratio} space for all
line ratios returned by MAPPINGS using Akima splines. Resampled grids
can be accessed via the sampling keyword. Diagnotic grids resampled 2x2
times are shipped in the default pyqz package and are directly
accessible, e.g.:
::
    bad_segments = pyqz.check_grid('[NII]/[OII]+;[OIII]/[SII]+',show_plot=True, sampling=2)

In the default pyqz diagrams, the original MAPPINGS nodes are circled
with a black outline, while the reconstructed nodes are not.

Basic use 2: deriving logQ and Tot[O+12] for a given set of line ratios
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

At the core of pyqz lies pyqz.interp\_qz(), which is the basic routine
used to interpolate a given line ratio diagnostic grid. The function is
being fed by line ratios stored inside numpy arrays, and will only
return a value for line ratios landing on valid and un-wrapped regions
of the grid:
::
    >>> z = pyqz.interp_qz('Tot[O]+12',[np.array([-0.6]),np.array([-0.1])],'[NII]/[OII]+;[OIII]/[SII]+', 
                   sampling=1,struct='pp', show_plot=True)
    >>> print z
    [ 8.67290484]

.. image:: output_17_0.png
   :align: center

Of course, one usually wants to compute both logQ and Tot[O+12] or
gas[O+12] for a large set of strong emission line fluxes, combining the
estimates from different line ratio diagnostics diagrams. This is
exactly what the function pyqz.get\_global\_qz() allows you to do.

The function is being fed the individual line fluxes and associated
errors in the form of numpy arrays and lists. ID tags for each dataset
can also be given to the function (these are then used if/when saving
the different diagrams to files).
::
    >>> pyqz.get_global_qz(np.array([[2.88,0.05,1.0,0.01,2.015,0.045,0.036,0.002,2.72,0.12,0.497,0.017,0.500,0.016]]),
                       ['[OII]+','std[OII]+','Hb','stdHb','[OIII]','std[OIII]','[OI]','std[OI]','Ha','stdHa','[NII]','std[NII]','[SII]+','std[SII]+'], 
                       ['[NII]/[SII]+;[OIII]/[SII]+','[NII]/[OII]+;[OIII]/[OII]+'], 
                       ids = ['NGC_1234'],
                       show_plot='KDE', # set this to True to also see the individual line ratio diagrams
                       save_plot=True,  # set this to 'grids', 'KDE_all', False or 'KDE_flags' (i.e. only the problematic points) 
                       plot_loc = './example_plots', 
                       struct='pp',
                       sampling=1)

By default, all line fluxes errors are assumed to be gaussian, where the
input std value is the 1 standard deviation. Alternatively, line fluxes
can be tagged as upper-limits by setting their errors to -1.

Users less keen on using Python extensively can alternatively feed their
data to pyqz via an appropriately structured .csv file and receive
another .csv file in return:
::
    >>> pyqz.get_global_qz_ff('./example_input.csv', 
                          ['[NII]/[SII]+;[OIII]/[SII]+','[NII]/[OII]+;[OIII]/[OII]+'], 
                          show_plot='KDE', # set this to True to also see the individual line ratio diagrams
                          save_plot=True,  # set this to 'grids', 'KDE_all', False or 'KDE_flags' (i.e. only the problematic points) 
                          plot_loc = './example_plots', 
                          struct='pp',
                          sampling=1)

Advanced use 1: using custom MAPPINGS grids
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

While pyqz ships with a default set of HII region simulations from
MAPPINGS, some (all!) users might be interested in using pyqz with their
own specific sets of MAPPINGS simulations. pyqz was designed to be
compatible with the grids generated from the awk script provided
alongside MAPPINGS.

If one uses the awk script to create new MAPPINGS grids, the resulting
.csv file must be laced inside pyqz/reference\_data. The filename must
match what the function pyqz.get\_MVphotogrid\_fn() expects for your
given set of parameters:
::
    >>> required_fn = pyqz.get_MVphotogrid_fn(Pk=6.7,calibs='GCZO', kappa =10, struct='pp')
    >>> print required_fn

If one does not use the awk script to generate the custom MAPPINGS grid,
then just make sure your model grid matches the format of existing model
grids located in pyqz/reference\_data/ ...

Advanced usage 2: "3-D" line ratio diagrams
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

pyqz does support 2-D line ratio diagrams constructed from 3 sets of
line ratios (i.e. 3-D line ratio diagrams projected to a given 2-D
plane):
::
    >>> bad_segments = pyqz.check_grid('[NII]/[SII]+;[NII]/Ha;[OIII]/Hb',
                    coeffs = [[1.0,0.264,0.0],[0.242,-0.910,0.342]],
                    show_plot=True,
                    struct='pp',
                    sampling=1)


.. image:: output_29_0.png
Ê  :align:center
